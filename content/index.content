<h1>mantis</h1>
<h2>mantis</h2>
<h3>mantis</h3>
<h4>mantis</h4>
<h5>mantis</h5>
<h6>mantis</h6>

<p>
	playground for mantis website - homepage currently messy tinkering with playground for <mono>mantis-highlight</mono> and <mono>mantis-editor</mono>..
</p><br><br>

<h3>highlighter/editor usecases (non-exclusive)</h3>
<ul align="left">
	<li>stylable syntax highlighting with rainbow brackets/selectors/properties/etc.</li>
	<li>website animations with text</li>
	<li>web editors/ides/clis/terminals/etc.</li>
	<li>chat bots</li>
</ul>

<h2>mantis-editor</h2><br>
<div contenteditable 
	align="center"
	class="microlight pre-wrap"
	id="mantis-editor"
	spellcheck="false"
	onkeydown="key_press(event)"
>//edit me v2.0

int main() {
	std::cout << "hello, world!" << std::endl;

	return 0;
}

</div>

<div id="editor-container" align="center">
<div id="editor-content" class="microlight pre-wrap" contenteditable spellcheck="false"></div>
<div id="editor" class="pre-wrap" contenteditable spellcheck="false" onkeyup="redraw_editor()" onkeydown="redraw_editor()">
//edit me v1.0

int main() {
	std::cout << "hello, world!" << std::endl;

	return 0;
}
</div></div>

<pre class="microlight wrap">
/*
	mantis editor v2.0 notes:
	-------------------------

	- gets and sets the caret properly each content modifying key stroke 
	- turns out you can just let the normal event run for non content modifying key strokes because it doesn't require the content being modified or redoing syntax highlighting, both of which reset the caret position (eg. arrow keys)
	- need to implement calling reset on single element rather than rehighlighting entire page
	- if I could figure out how to rehighlight and reset the caret position after letting only the events we want to run (ie. not be prevented) then could potentially avoid having to do two bfs searches of the text nodes (haven't been able to avoid searching:
		1. before modifying and rehighlighting as need to get the full current position of caret, which could have changed even from using the mouse and hard to keep a global pos variable when events are firing frequently, otherwise could potentially keep track of caret position from keystrokes and do bfs/dfs search to update caret position onclick)
		2. after modifying and rehighlighting (haven't been able to keep track of the focusNode from before modification/rehighlighting and after, quite likely from the text nodes being recreated though that's under the hood for js and not sure where to really check what it's doing or if it'd even be browser independent, likely js implementation independent?)
	- haven't implemented ctrl+* but should be able to along with custom hard-coded and custom user-defined commands (along with alt/cmd/etc.), have blocked ctrl from adding to text without blocking usual ctrl event but eg ctrl+c will still insert 'c' (however can select with both shift arrows or using mouse and then right click to copy/paste, caveat however is that it doesn't actually redo the syntax highlighting, but does replicate the syntax highlighting if copied from any syntax highlighted element)
	- [!!] undo/redo doesn't work with ctrl+z/ctrl+shift+z nor is it available with right click (presumably because for modifying keystrokes I'm still searching for the focus node to get the full pos of the caret, inserting changes manually, rehighlighting then resetting the caret). Even if the majority of modifying keystrokes could be implemented manually tab in particular seems to require manually inserting '\t' and arguably rehighlighting (could be breaking up text which was highlighted and/or one/both halves are highlighted), manually implementing undo/redo might be a real pita
	- should be trivial to add in user-resizing and max-height with scrolling
	- hopefully more performant but need to work out how to test/verify that (especially when content modifying keystrokes for v1.0 does not use two bfs searches of the text nodes, though should be able to avoid this when editing the same line (just need to store previous search results))
	- do we need to do full bfs (or dfs?) searches of the text nodes? ie. can an element of a text line have children? In which case does it matter if we do bfs or dfs search? dfs* would allow popping nodes from the stack as we search but bfs 'seems' right (haven't even tried to test if I can add child nodes to text nodes for a given line). note: iirc building page with single line editor content seemed to have the text nodes for that line as the children of the editor div, whereas for multiple lines the children of the editor div seemed to be the line nodes (each of which made up of text nodes)
	- doesn't have a caret lag when holding keys (including backspace)
	- doesn't require as many css hacks which may break unexpectedly in random places (eg. transparent text/caret getting out of sync with displayed text which can happen for all sorts of nuanced reasons and be a pita to debug)

	- need to check if off-screen content for scrollable divs affects performance much, can it be removed from the div and improve performance updating as the user scrolls/edits? What about when combined with making sure syntax highlighting isn't affected? Should at least be able to do after viewable content, though in that case could be better to highlight and store everything in reverse as more likely to be towards the end of documents being edited.. Alternatively can store state of highliter (eg. brace depth, brace stack etc.) x lines prior to viewable content and reload div content as user scrolls (lazy loading kind of approach)
*/
</pre>

<pre class="microlight wrap">
/*
	mantis editor v1.0 notes:
	-------------------------

	- has overlapping divs (editable div has transparent font color)
	- caret lags 1 position when holding keys
	- need to implement caret getting/setting anyway for stuff like tab insertion, commands, terminal-like carets etc..
	- works out of the box for stuff like arrow keys, backspace, enter, selecting/copying text, undo/redo (still haven't figured out undo/redo for v2.0) etc..
	- seems to be difficult to make user-resizable or have max-height with scrolling, attempts to have event listeners on resize of editable transparent-font div to also resize highlighted div resulted in very jumpy behaviour in browser (too chaotic to check within any reasonable tolerances)
*/
</pre><br><br>

<h2>mantis-highlight</h2><br>
<pre class="microlight wrap">
/* 
	scss example:
*/

$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body {
	font: 100% $font-stack;
	color: $primary-color;
}

nav {
	margin : 0;
	padding: 0;

	ul {
		margin : 0;
		padding: 0;
		list-style: none;
	}

	li { display: inline-block; }

	a {
		display: block;
		padding: 6px 12px;
		text-decoration: none;
	}
}

\@mixin theme(\$theme: DarkGray) {
	background: \$theme;
	box-shadow: 0 0 1px rgba(\$theme, .25);
	color: #fff;
}

.info {
	\@include theme;
}
.alert {
	\@include theme($theme: DarkRed);
}
.success {
	\@include theme($theme: DarkGreen);
}

\@use "sass:math";

.container {
	display: flex;
}

article[role="main"] {
	width: math.div(600px, 960px) * 100%;
}

aside[role="complementary"] {
	width: math.div(300px, 960px) * 100%;
	margin-left: auto;
}
</pre>

<pre class="microlight wrap">
/* 
	scss example notes:
	-------------------

	- brackets are rainbow colored depending on nested depth, provides visually digestible information about whether brackets syntactically correct, eg. have matching close brackets of the right type in the right place, and makes it easy to find matching open/close brackets when reading code
	- selectors/properties are also rainbow colored depending on depth of nesting within brackets, helpful for similar reasons to rainbow brackets, eg. for identifying which nest level a selector/property is at
	- bracket/selector/property/number colours have animating hues presently 
	- need to implement calling reset on single element rather than rehighlighting entire page, eg. for editor and using client side js to modify/set/load/etc. a mantis-highlight element 
*/
</pre><br>

<pre class="microlight">
<!-- example nift/mantis html.template file -->

<!doctype html>
<html lang="en">
	<head>
		\@input("templates/head.template")
	</head>

	<body>
		<div align="center">
			\@input("templates/menu.template")

			<div id="content">
				\@content

				\@//input("templates/footer.template")
			</div>
		</div>

		<script defer
			type = "text/javascript" 
			src  = "\@pathto(output/assets/js/bundled.js)"
		></script>
	</body>
</html>
</pre><br>

@input("content/microlight-highlighted.content")

<pre class="microlight wrap">
/*
	micrlight highlighted example notes:
	-------------------

	will figure out how to fix bracket issues, and ensure it's able to highlight final minified version of mantis-highlight and mantis-editor once finished, cleaned up and minified etc.., need to fix up issues with minifier too
*/
</pre><br>

<pre class="microlight">
using namespace std;

int main() {
	std::cout << "hello, world!" << std::endl;

	for(auto i=0; i<j -123423423410; ++i) {
		for(std::size_t j=12; j>= 0; --j)
			{std::cout << "lolo there" << std::endl;}
	}

	return 0;
}


array {{{}}}
array {{{}}}
array {+{-{}*}!}
p::+ { color: red }
{<div><span>hello {{{{{{}}}}}}   </span></div>}

"this is a string"
'c'
</pre>
