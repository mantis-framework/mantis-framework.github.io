<h1>mantis</h1>
<h2>mantis</h2>
<h3>mantis</h3>
<h4>mantis</h4>
<h5>mantis</h5>
<h6>mantis</h6>

<p>
	sd f sdf sdf s dfsd f sdf sd fsd fsd f df df sdf df sf sf sd ad g  g gw e f sdf sdf sd fs d fsd fsd f df df sdf df sf sf sd ad g  g gw e f sdf sdf sd fs gs d f sdf sdf sf sd fs df sd fs df sdf sd f sdf sdf s dfsd f sdf sd fsd fsd f df df sdf df sf sf sd ad g  g gw e f sdf sdf df sd fs d fsd fsd f df df sdf df sf sf sd ad g  g gw e f sdf sdf sd fs gs d f sdf sdf sf sd fs df sd fs df sdf sd f sdf sdf s dfsd f sdf sd fsd fsd f df df sdf df sf sf sd ad g  g gw e f sdf s
</p>

<div contenteditable 
	align="center"
	class="microlight pre-wrap"
	id="mantis-editor"
	spellcheck="false"
	onkeydown="key_press(event)" 
>/*
	mantis editor v2.0 
		- gets and sets the caret properly each key stroke
		- less features implemented (plus less features come 'out of the box')
		- hopefully more performnat but need to work out how to test/verify that (especially when normal text insertion for v1.0 does not use two bfs or dfs searches of the text nodes, though should be able to avoid this when editing the same line (just need to store previous search results))
		- do we need to do full dfs or bfs searches of the text nodes? ie. can an element of a text line have children? In which case does it matter if we do bfs or dfs search? bfs would allow popping nodes from the stach as we search. note: iirc building page with single line editor content seemed to have the text nodes for that line as the children of the editor div, whereas for multiple lines the children of the editor div seemed to be the line nodes (each of which made up of text nodes)
		- doesn't have a caret lag when holding keys (including backspace)
		- doesn't require as many hacks which may break unexpectedly in random places

		- need to check if off-screen content for scrollable divs affects performance much, can it be removed from the div and improve performance updating as the user scrolls/edits? What about when combined with making sure syntax highlighting isn't affected? Should at least be able to do after viewable content, though in that case could be better to highlight and store everything in reverse as more likely to be towards the end of documents being edited..
*/

int main() {
	std::cout << "hello, world!" << std::endl;

	return 0;
}

</div>

<div id="editor-container" align="center">
<div id="editor-content" class="microlight pre-wrap" contenteditable spellcheck="false"></div>
<div id="editor" class="pre-wrap" contenteditable spellcheck="false" onkeyup="redraw_editor()" onkeydown="redraw_editor()">/*
	mantis editor v1.0
		- has overlapping divs (editable div has transparent font color)
		- caret lags 1 position when holding keys
		- need to implement caret getting/setting anyway for stuff like tab insertion, commands, terminal-like carets etc..
		- works out of the box for stuff like arrow keys, backspace, enter, selecting/copying text etc..
*/

int main() {
	std::cout << "hello, world!" << std::endl;

	return 0;
}

</div>
</div>

<pre class="microlight">
/* scss */
$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body {
  font: 100% $font-stack;
  color: $primary-color;
}

nav {
	ul {
		margin: 0;
		padding: 0;
		list-style: none;
	}

	li { display: inline-block; }

	a {
		display: block;
		padding: 6px 12px;
		text-decoration: none;
	}
}

\@mixin theme(\$theme: DarkGray) {
  background: \$theme;
  box-shadow: 0 0 1px rgba(\$theme, .25);
  color: #fff;
}

.info {
  \@include theme;
}
.alert {
  \@include theme($theme: DarkRed);
}
.success {
  \@include theme($theme: DarkGreen);
}

\@use "sass:math";

.container {
  display: flex;
}

article[role="main"] {
  width: math.div(600px, 960px) * 100%;
}

aside[role="complementary"] {
  width: math.div(300px, 960px) * 100%;
  margin-left: auto;
}
</pre>


<pre class="microlight">
using namespace std;

int main() {
	std::cout << "hello, world!" << std::endl;

	for(auto i=0; i<j -123423423410; ++i) {
		for(std::size_t j=12; j>= 0; --j)
			{std::cout << "lolo there" << std::endl;}
	}

	return 0;
}


array {{{}}}
array {{{}}}
array {+{-{}*}!}
p::+ { color: red }
{<div><span>hello {{{{{{}}}}}}   </span></div>}

"this is a string"
'c'
</pre>

<pre class="microlight linenums">
<!doctype html>
<html lang="en">
	<head>
		\@input("templates/head.template")
	</head>

	<body>
		<div align="center">
			\@input("templates/menu.template")

			<div id="content">
				\@content

				\@//input("templates/footer.template")
			</div>
		</div>

		<script defer
			type = "text/javascript" 
			src  = "\@pathto(output/assets/js/bundled.js)"
		></script>
	</body>
</html>
</pre>